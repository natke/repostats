[
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/788403396",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6824#issuecomment-788403396",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6824",
        "id": 788403396,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc4ODQwMzM5Ng==",
        "user": {
            "login": "fdwr",
            "id": 1809166,
            "node_id": "MDQ6VXNlcjE4MDkxNjY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1809166?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fdwr",
            "html_url": "https://github.com/fdwr",
            "followers_url": "https://api.github.com/users/fdwr/followers",
            "following_url": "https://api.github.com/users/fdwr/following{/other_user}",
            "gists_url": "https://api.github.com/users/fdwr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fdwr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fdwr/subscriptions",
            "organizations_url": "https://api.github.com/users/fdwr/orgs",
            "repos_url": "https://api.github.com/users/fdwr/repos",
            "events_url": "https://api.github.com/users/fdwr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fdwr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-03-01T23:40:31Z",
        "updated_at": "2021-03-01T23:48:47Z",
        "author_association": "MEMBER",
        "body": "@MaxHuerlimann: In theory, interop between CUDA and D3D12 should be possible using shared memory regions, but we have no support for this - the built-in interop with CUDA in the DML EP requires a roundtrip to CPU. Alas I'm unfamiliar with Cuda API and don't know how to advise getting the content of the cudaArray to bind to D3D12 input resources. :/",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/788403396/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/803626509",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6824#issuecomment-803626509",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6824",
        "id": 803626509,
        "node_id": "MDEyOklzc3VlQ29tbWVudDgwMzYyNjUwOQ==",
        "user": {
            "login": "MaxHuerlimann",
            "id": 22450251,
            "node_id": "MDQ6VXNlcjIyNDUwMjUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22450251?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MaxHuerlimann",
            "html_url": "https://github.com/MaxHuerlimann",
            "followers_url": "https://api.github.com/users/MaxHuerlimann/followers",
            "following_url": "https://api.github.com/users/MaxHuerlimann/following{/other_user}",
            "gists_url": "https://api.github.com/users/MaxHuerlimann/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/MaxHuerlimann/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MaxHuerlimann/subscriptions",
            "organizations_url": "https://api.github.com/users/MaxHuerlimann/orgs",
            "repos_url": "https://api.github.com/users/MaxHuerlimann/repos",
            "events_url": "https://api.github.com/users/MaxHuerlimann/events{/privacy}",
            "received_events_url": "https://api.github.com/users/MaxHuerlimann/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-03-21T17:18:32Z",
        "updated_at": "2021-03-21T17:46:48Z",
        "author_association": "NONE",
        "body": "So after some further research I also think this should be doable. It should work with [these](https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__D3D11.html#group__CUDART__D3D11) and [these](https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP) functions. But for these to be of any help, I would need to have a way to bind the data in the 2D texture to a [VideoFrame](https://docs.microsoft.com/en-us/uwp/api/windows.media.videoframe?view=winrt-19041), which has a method that takes a `IDirect3DSurface`. I am not very familiar with Direct3D, so I am not really sure how to achieve this or if it is even possible to get a reference to the surface storing the image data, @fdwr maybe you know of a way?",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/803626509/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/803676579",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6824#issuecomment-803676579",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6824",
        "id": 803676579,
        "node_id": "MDEyOklzc3VlQ29tbWVudDgwMzY3NjU3OQ==",
        "user": {
            "login": "MaxHuerlimann",
            "id": 22450251,
            "node_id": "MDQ6VXNlcjIyNDUwMjUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22450251?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MaxHuerlimann",
            "html_url": "https://github.com/MaxHuerlimann",
            "followers_url": "https://api.github.com/users/MaxHuerlimann/followers",
            "following_url": "https://api.github.com/users/MaxHuerlimann/following{/other_user}",
            "gists_url": "https://api.github.com/users/MaxHuerlimann/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/MaxHuerlimann/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MaxHuerlimann/subscriptions",
            "organizations_url": "https://api.github.com/users/MaxHuerlimann/orgs",
            "repos_url": "https://api.github.com/users/MaxHuerlimann/repos",
            "events_url": "https://api.github.com/users/MaxHuerlimann/events{/privacy}",
            "received_events_url": "https://api.github.com/users/MaxHuerlimann/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-03-21T23:09:04Z",
        "updated_at": "2021-03-21T23:09:04Z",
        "author_association": "NONE",
        "body": "I believe I figured out how to get the shared surface (following the official documentation [here](https://docs.microsoft.com/en-us/windows/win32/direct3darticles/surface-sharing-between-windows-graphics-apis)). Let's see if I can make it work.",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/803676579/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/824747409",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6824#issuecomment-824747409",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6824",
        "id": 824747409,
        "node_id": "MDEyOklzc3VlQ29tbWVudDgyNDc0NzQwOQ==",
        "user": {
            "login": "MaxHuerlimann",
            "id": 22450251,
            "node_id": "MDQ6VXNlcjIyNDUwMjUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22450251?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MaxHuerlimann",
            "html_url": "https://github.com/MaxHuerlimann",
            "followers_url": "https://api.github.com/users/MaxHuerlimann/followers",
            "following_url": "https://api.github.com/users/MaxHuerlimann/following{/other_user}",
            "gists_url": "https://api.github.com/users/MaxHuerlimann/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/MaxHuerlimann/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MaxHuerlimann/subscriptions",
            "organizations_url": "https://api.github.com/users/MaxHuerlimann/orgs",
            "repos_url": "https://api.github.com/users/MaxHuerlimann/repos",
            "events_url": "https://api.github.com/users/MaxHuerlimann/events{/privacy}",
            "received_events_url": "https://api.github.com/users/MaxHuerlimann/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-04-22T11:09:32Z",
        "updated_at": "2021-04-22T11:09:32Z",
        "author_association": "NONE",
        "body": "So, I moved away from using D3D11 and started using D3D12 as model outputs would require allocating Tensors with `ITensorStaticsNative` anyways, which consumes `ID3D12Resource`, so I am not trying to use `VideoFrame`s, but rather implement custom tensorization as shown [here](https://github.com/microsoft/Windows-Machine-Learning/blob/master/Samples/CustomTensorization/CustomTensorization/TensorConvertor.cpp). I have setup surface sharing using [CUDA External Resource Interoperability](https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__EXTRES__INTEROP.html#group__CUDART__EXTRES__INTEROP) similar to [here](https://github.com/mprevot/CudaD3D12Update/blob/master/simpleD3D12update.cpp). As I don't need to render anything, I thought I was able to simply create the heap and resource and then copy the incoming cudaArray into the interop cudaArray as shown below, without needing to create any sort of command queue. Note that the missing code is the same as in the linked github repo above, so I left it out for conciseness.\r\nThis approach does not work, but I am not sure how to debug this, as I am new to Direct3D programming and GPU programming in general. Some direction on what should be fixed here would be greatly appreciated :) I was thinking that I need to use a semaphore for some kind of syncing, but I am not sure if that works without creating some sort of command queue. Or should I post this on the Windows-Machine-Learning repo, as this doesn't directly concern ORT?\r\n```\r\nbool initD3d12() {\r\n  UINT dxgiFactoryFlags = 0;\r\n  winrt::com_ptr<IDXGIFactory4> factory;\r\n  winrt::check_hresult(CreateDXGIFactory2(dxgiFactoryFlags, IID_PPV_ARGS(factory.put())));\r\n  winrt::com_ptr<IDXGIAdapter1> hardwareAdapter;\r\n  GetHardwareAdapter(factory.get(), hardwareAdapter.put());\r\n  \r\n  winrt::check_hresult(D3D12CreateDevice(hardwareAdapter.get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(m_d3d12Device.put())));\r\n  \r\n  DXGI_ADAPTER_DESC1 desc;\r\n  hardwareAdapter->GetDesc1(&desc);\r\n  m_dx12deviceluid = desc.AdapterLuid;\r\n  \r\n  return true;\r\n}\r\n  \r\nvoid initCuda() {\r\n  int num_cuda_devices = 0;\r\n  checkCudaErrors(cudaGetDeviceCount(&num_cuda_devices));\r\n  \r\n  if (!num_cuda_devices) {\r\n\t  throw std::exception(\"No CUDA Devices found\");\r\n  }\r\n  for (int devId = 0; devId < num_cuda_devices; devId++) {\r\n\t  cudaDeviceProp devProp;\r\n\t  checkCudaErrors(cudaGetDeviceProperties(&devProp, devId));\r\n  \r\n\t  if ((memcmp(&m_dx12deviceluid.LowPart, devProp.luid,\r\n\t\t  sizeof(m_dx12deviceluid.LowPart)) == 0) &&\r\n\t\t  (memcmp(&m_dx12deviceluid.HighPart,\r\n\t\t\t  devProp.luid + sizeof(m_dx12deviceluid.LowPart),\r\n\t\t\t  sizeof(m_dx12deviceluid.HighPart)) == 0)) {\r\n\t\t  checkCudaErrors(cudaSetDevice(devId));\r\n\t\t  m_cudaDeviceID = devId;\r\n\t\t  m_nodeMask = devProp.luidDeviceNodeMask;\r\n\t\t  checkCudaErrors(cudaStreamCreate(&m_streamToRun));\r\n\t\t  printf(\"CUDA Device Used [%d] %s\\n\", devId, devProp.name);\r\n\t\t  break;\r\n\t  }\r\n  }\r\n}\r\n  \r\nvoid copyArrayToResource(cudaArray_t cudaArray) {\r\n  // then we want to copy cudaLinearMemory to the D3D texture, via its mapped form : cudaArray\r\n  cudaMemcpy2DArrayToArray(\r\n\t  m_cudaArray, // dst array\r\n\t  0, 0,    // offset\r\n\t  cudaArray, 0, 0,       // src\r\n\t  m_width * 4 * sizeof(float), m_height, // extent\r\n\t  cudaMemcpyDeviceToDevice); // kind\r\n}\r\n  \r\nvoid createResource(size_t width, size_t height, ID3D12Resource** d3d12Resource) {\r\n  m_width = width;\r\n  m_height = height;\r\n  // Create D3D12 2DTexture\r\n  // Assume 32-Bit float RGBA image\r\n  const auto channels = 4;\r\n  const auto textureSurface = width * height;\r\n  const auto texturePixels = textureSurface * channels;\r\n  const auto textureSizeBytes = sizeof(float)* texturePixels;\r\n  \r\n  const auto texFormat = channels == 4 ? DXGI_FORMAT_R32G32B32A32_FLOAT : DXGI_FORMAT_R32G32B32_FLOAT;\r\n  const auto texDesc = CD3DX12_RESOURCE_DESC::Tex2D(texFormat, width, height, 1, 1, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS);\r\n  D3D12_HEAP_PROPERTIES heapProperties = {\r\n\t  D3D12_HEAP_TYPE_DEFAULT,\r\n\t  D3D12_CPU_PAGE_PROPERTY_UNKNOWN,\r\n\t  D3D12_MEMORY_POOL_UNKNOWN,\r\n\t  0,\r\n\t  0};\r\n  \r\n  winrt::check_hresult(m_d3d12Device->CreateCommittedResource(\r\n\t  &heapProperties,\r\n\t  D3D12_HEAP_FLAG_SHARED,\r\n\t  &texDesc,\r\n\t  D3D12_RESOURCE_STATE_COMMON,\r\n\t  nullptr,\r\n\t  IID_PPV_ARGS(d3d12Resource)));\r\n  \r\n  \r\n  // Create CUDA external resource\r\n  HANDLE sharedHandle;\r\n  WindowsSecurityAttributes windowsSecurityAttributes{};\r\n  LPCWSTR name = NULL;\r\n  winrt::check_hresult(m_d3d12Device->CreateSharedHandle(\r\n\t  *d3d12Resource, &windowsSecurityAttributes, GENERIC_ALL, 0,\r\n\t  &sharedHandle));\r\n  \r\n  D3D12_RESOURCE_ALLOCATION_INFO d3d12ResourceAllocationInfo;\r\n  d3d12ResourceAllocationInfo = m_d3d12Device->GetResourceAllocationInfo(\r\n\t  m_nodeMask, 1, &texDesc);\r\n  size_t actualSize = d3d12ResourceAllocationInfo.SizeInBytes;\r\n  size_t alignment = d3d12ResourceAllocationInfo.Alignment;\r\n  \r\n  cudaExternalMemoryHandleDesc externalMemoryHandleDesc;\r\n  memset(&externalMemoryHandleDesc, 0, sizeof(externalMemoryHandleDesc));\r\n  \r\n  externalMemoryHandleDesc.type = cudaExternalMemoryHandleTypeD3D12Resource;\r\n  externalMemoryHandleDesc.handle.win32.handle = sharedHandle;\r\n  externalMemoryHandleDesc.size = actualSize;\r\n  externalMemoryHandleDesc.flags = cudaExternalMemoryDedicated;\r\n  \r\n  checkCudaErrors(\r\n\t  cudaImportExternalMemory(&m_externalMemory, &externalMemoryHandleDesc));\r\n  \r\n  cudaExternalMemoryMipmappedArrayDesc cuExtmemMipDesc{};\r\n  cuExtmemMipDesc.extent = make_cudaExtent(width, height, 0);\r\n  cuExtmemMipDesc.formatDesc = cudaCreateChannelDesc<float4>();\r\n  cuExtmemMipDesc.numLevels = 1;\r\n  cuExtmemMipDesc.flags = cudaArrayDefault;\r\n  \r\n  cudaMipmappedArray_t cuMipArray{};\r\n  checkCudaErrors(cudaExternalMemoryGetMappedMipmappedArray(&cuMipArray, m_externalMemory, &cuExtmemMipDesc));\r\n  \r\n  checkCudaErrors(cudaGetMipmappedArrayLevel(&m_cudaArray, cuMipArray, 0));\r\n}\r\n```",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/824747409/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/825193916",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6824#issuecomment-825193916",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6824",
        "id": 825193916,
        "node_id": "MDEyOklzc3VlQ29tbWVudDgyNTE5MzkxNg==",
        "user": {
            "login": "fdwr",
            "id": 1809166,
            "node_id": "MDQ6VXNlcjE4MDkxNjY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1809166?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fdwr",
            "html_url": "https://github.com/fdwr",
            "followers_url": "https://api.github.com/users/fdwr/followers",
            "following_url": "https://api.github.com/users/fdwr/following{/other_user}",
            "gists_url": "https://api.github.com/users/fdwr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fdwr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fdwr/subscriptions",
            "organizations_url": "https://api.github.com/users/fdwr/orgs",
            "repos_url": "https://api.github.com/users/fdwr/repos",
            "events_url": "https://api.github.com/users/fdwr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fdwr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-04-22T21:21:29Z",
        "updated_at": "2021-04-22T21:21:29Z",
        "author_association": "MEMBER",
        "body": "@MaxHuerlimann: Does that mean you're going through ORT via WinML now, rather than directly targeting the ORT API? What kind of error do you get, or do you get no error at all, just that you don't get the tensor data? (e.g. maybe all zeros or garbage) I'm sadly ignorant regarding CUDA interop ðŸ˜”, but I think it would be a good sample to add to Windows Machine Learning. @martinb35 and @orilevari, what do you think about adding a sample to Windows Machine Learning, showing how users can get output from CUDA as input into a Direct3D resource for WinML, kinda like we already have https://github.com/microsoft/Windows-Machine-Learning/tree/master/Samples/CustomTensorization?",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/825193916/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/825446478",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6824#issuecomment-825446478",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6824",
        "id": 825446478,
        "node_id": "MDEyOklzc3VlQ29tbWVudDgyNTQ0NjQ3OA==",
        "user": {
            "login": "MaxHuerlimann",
            "id": 22450251,
            "node_id": "MDQ6VXNlcjIyNDUwMjUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22450251?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MaxHuerlimann",
            "html_url": "https://github.com/MaxHuerlimann",
            "followers_url": "https://api.github.com/users/MaxHuerlimann/followers",
            "following_url": "https://api.github.com/users/MaxHuerlimann/following{/other_user}",
            "gists_url": "https://api.github.com/users/MaxHuerlimann/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/MaxHuerlimann/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MaxHuerlimann/subscriptions",
            "organizations_url": "https://api.github.com/users/MaxHuerlimann/orgs",
            "repos_url": "https://api.github.com/users/MaxHuerlimann/repos",
            "events_url": "https://api.github.com/users/MaxHuerlimann/events{/privacy}",
            "received_events_url": "https://api.github.com/users/MaxHuerlimann/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-04-23T07:14:29Z",
        "updated_at": "2021-04-23T07:14:29Z",
        "author_association": "NONE",
        "body": "@fdwr Yes, currently I am using WinML, as their C++ API is better documented, especially regarding consuming GPU resources. In ORT I still see some conflicting information regarding the `IOBinding` functionality.\r\nCurrently the creation of an input tensor using the `ITensorStaticsNative` interface that allows consuming a GPU resource just fails, so I can't confidently say what is the problem. I assume one would need to copy the `ID3D12Resource` data to the CPU to inspect it, right? With CUDA I can do this rater simply but with direct3d12 it seems that one needs to setup a command queue and more resources. If you can point me to a good resource on how to inspect d3d12 GPU resources that would be amazing, then I could provide more detailed information.\r\nIt would be awesome if a sample existed!",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/825446478/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]