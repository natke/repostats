[
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/778420259",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6087#issuecomment-778420259",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6087",
        "id": 778420259,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3ODQyMDI1OQ==",
        "user": {
            "login": "SherlockNoMad",
            "id": 9906745,
            "node_id": "MDQ6VXNlcjk5MDY3NDU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/9906745?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/SherlockNoMad",
            "html_url": "https://github.com/SherlockNoMad",
            "followers_url": "https://api.github.com/users/SherlockNoMad/followers",
            "following_url": "https://api.github.com/users/SherlockNoMad/following{/other_user}",
            "gists_url": "https://api.github.com/users/SherlockNoMad/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/SherlockNoMad/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/SherlockNoMad/subscriptions",
            "organizations_url": "https://api.github.com/users/SherlockNoMad/orgs",
            "repos_url": "https://api.github.com/users/SherlockNoMad/repos",
            "events_url": "https://api.github.com/users/SherlockNoMad/events{/privacy}",
            "received_events_url": "https://api.github.com/users/SherlockNoMad/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-12T19:57:31Z",
        "updated_at": "2021-02-12T19:57:31Z",
        "author_association": "CONTRIBUTOR",
        "body": "Hi @chethanpk, ORT Training currently doesn't target vision/image models. We had a preliminary implementation for BatchNormGradient, but it's not yet fully tested on various models. ",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/778420259/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/792230591",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6087#issuecomment-792230591",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6087",
        "id": 792230591,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc5MjIzMDU5MQ==",
        "user": {
            "login": "pranav-prakash",
            "id": 10335022,
            "node_id": "MDQ6VXNlcjEwMzM1MDIy",
            "avatar_url": "https://avatars.githubusercontent.com/u/10335022?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/pranav-prakash",
            "html_url": "https://github.com/pranav-prakash",
            "followers_url": "https://api.github.com/users/pranav-prakash/followers",
            "following_url": "https://api.github.com/users/pranav-prakash/following{/other_user}",
            "gists_url": "https://api.github.com/users/pranav-prakash/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/pranav-prakash/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/pranav-prakash/subscriptions",
            "organizations_url": "https://api.github.com/users/pranav-prakash/orgs",
            "repos_url": "https://api.github.com/users/pranav-prakash/repos",
            "events_url": "https://api.github.com/users/pranav-prakash/events{/privacy}",
            "received_events_url": "https://api.github.com/users/pranav-prakash/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-03-07T07:15:17Z",
        "updated_at": "2021-03-07T07:16:07Z",
        "author_association": "CONTRIBUTOR",
        "body": "Since I needed this working, here's a hacky patch (completely untested since it's still WIP but I'll update in case anything is significantly wrong. At least it doesn't complain about missing edges or unregistered ops anymore)\r\n\r\nThere are three main pieces that were missing:\r\n\r\n* Blacklist the mean/variance tensors from having their gradients calculated. These are calculated directly from the batch during training and are not updated via backprop\r\n* The onnx spec for BatchNorm currently doesn't provide an attribute to distinguish between training/inference mode (since batch norm has different behavior in both cases). https://github.com/onnx/onnx/issues/1042 While we can assume the presence of the optional outputs indicates we're doing training, it's technically valid for a serialized model for inference to contain those as well. \r\n* Regardless we boldly carry on with our shaky assumptions and update the batch normalization CPU operator to support outputting saved_mean/saved_variance info. This terminology was a bit confusing at first: saved_mean/saved_variance refers to the mean/variance computed for a single batch. The running_mean/running_variance refer to the respective weighted quantities across all batches that have been seen.\r\n* The CPU implementation of the above was cribbed from caffe2 (as it appeared that the existing inference-only implementation was also taken from there). They do something weird where instead of outputting saved_variance they output inv_std_dev. Apparently this is for ease of interoperability with cuDNN, but it completely breaks the ONNX spec. Nonetheless, I've chosen to do the same because the existing cuda kernel for batchnormgrad also relies on it actually being inv_std_dev.\r\n* Added a CPU implementation for batchnormgrad (the below patches registers this op with a custom execution provider, but you can choose to do it with CPU). Again to match behavior with the cuda version we too completely break the spec and assume that the saved_var is actually inv_std_dev.\r\n\r\n\r\n\r\n```\r\ndiff --git a/onnxruntime/core/providers/cpu/nn/batch_norm.cc b/onnxruntime/core/providers/cpu/nn/batch_norm.cc\r\nindex 50d0bc21d..db50fe65e 100644\r\n--- a/onnxruntime/core/providers/cpu/nn/batch_norm.cc\r\n+++ b/onnxruntime/core/providers/cpu/nn/batch_norm.cc\r\n@@ -29,11 +29,12 @@ ONNX_CPU_OPERATOR_VERSIONED_TYPED_KERNEL(BatchNormalization, 7, 8, double,\r\n                                          KernelDefBuilder().TypeConstraint(\"T\", DataTypeImpl::GetTensorType<double>()),\r\n                                          BatchNorm<double>);\r\n \r\n+// We alias the running mean to the mean so it stays preserved across multiple batches\r\n ONNX_CPU_OPERATOR_TYPED_KERNEL(BatchNormalization, 9, float,\r\n-                               KernelDefBuilder().TypeConstraint(\"T\", DataTypeImpl::GetTensorType<float>()),\r\n+                               KernelDefBuilder().Alias(3,1).Alias(4,2).TypeConstraint(\"T\", DataTypeImpl::GetTensorType<float>()),\r\n                                BatchNorm<float>);\r\n \r\n ONNX_CPU_OPERATOR_TYPED_KERNEL(BatchNormalization, 9, double,\r\n-                               KernelDefBuilder().TypeConstraint(\"T\", DataTypeImpl::GetTensorType<double>()),\r\n+                               KernelDefBuilder().Alias(3,1).Alias(4,2).TypeConstraint(\"T\", DataTypeImpl::GetTensorType<double>()),\r\n                                BatchNorm<double>);\r\n }  // namespace onnxruntime\r\ndiff --git a/onnxruntime/core/providers/cpu/nn/batch_norm.h b/onnxruntime/core/providers/cpu/nn/batch_norm.h\r\nindex 46ca31053..d6800ca59 100644\r\n--- a/onnxruntime/core/providers/cpu/nn/batch_norm.h\r\n+++ b/onnxruntime/core/providers/cpu/nn/batch_norm.h\r\n@@ -35,7 +35,12 @@ class BatchNorm : public OpKernel {\r\n                                                            is_spatial_(op_kernel_info.GetAttrOrDefault<int64_t>(\"spatial\", 1) == 1) {\r\n     auto st = op_kernel_info.GetAttr<float>(\"epsilon\", &epsilon_);\r\n     ORT_ENFORCE(st.IsOK(), st.ErrorMessage());\r\n-\r\n+    is_train_ = OpKernel::Node().OutputDefs().size() == 5;\r\n+    if (is_train_) {\r\n+      ORT_ENFORCE(is_spatial_ == true, \"Non spatial convolution for training\");\r\n+    }\r\n+    auto mt = op_kernel_info.GetAttr<float>(\"momentum\", &momentum_);\r\n+    ORT_ENFORCE(mt.IsOK(), mt.ErrorMessage());\r\n     // For opset 6-8, if spatial attribute exists, pick up the value (by default spatial == 1)\r\n     // From opset 9 onwards, by default, only the spatial case (spatial == 1) is defined per spec\r\n \r\n@@ -70,14 +75,61 @@ class BatchNorm : public OpKernel {\r\n     ConstEigenVectorArrayMap<T> scale_arr(scale->template Data<T>(), is_spatial_ ? C : sample_size_incl_all_channels);\r\n     ConstEigenVectorArrayMap<T> bias_arr(B->template Data<T>(), is_spatial_ ? C : sample_size_incl_all_channels);\r\n \r\n+    // The saved mean corresponds to the mean from this batch\r\n+    auto* saved_mean = is_train_ ? p_op_kernel_context->Output(3, TensorShape({(int) C})) : nullptr;\r\n+    auto* saved_var = is_train_ ? p_op_kernel_context->Output(4, TensorShape({(int) C})) : nullptr;\r\n+\r\n+    // The running mean corresponds to the mean from all the batches\r\n+    // During inference this running mean is used as the mean for BN\r\n+    auto* running_mean = is_train_ ? p_op_kernel_context->Output(1, TensorShape({(int) C})) : nullptr;\r\n+    auto* running_var = is_train_ ? p_op_kernel_context->Output(2, TensorShape({(int) C})) : nullptr;\r\n+\r\n+    if (is_train_) {\r\n+      EigenVectorArrayMap<T> saved_mean_arr(saved_mean->template MutableData<T>(), C);\r\n+      EigenVectorArrayMap<T> saved_var_arr(saved_var->template MutableData<T>(), C);\r\n+      saved_mean_arr.setZero();\r\n+      saved_var_arr.setZero();\r\n+\r\n+      ConstEigenArrayMap<T> X_arr(X->template Data<T>(), sample_size, N * C);\r\n+      for (size_t nc = 0; nc < N * C; ++nc) {\r\n+        saved_mean_arr(nc % C) += X_arr.col(nc).sum();\r\n+      }\r\n+      saved_mean_arr /= N * sample_size;\r\n+      for (size_t nc = 0; nc < N * C; ++nc) {\r\n+        saved_var_arr(nc % C) += (X_arr.col(nc) - saved_mean_arr(nc % C)).matrix().squaredNorm();\r\n+      }\r\n+      saved_var_arr /= N * sample_size;\r\n+\r\n+      // Assume that running mean and variance are initialized properly in the model given to us\r\n+      // Because we alias it, we have the past history here\r\n+      EigenVectorArrayMap<T> running_mean_arr(\r\n+          running_mean->template MutableData<T>(), C);\r\n+      EigenVectorArrayMap<T> running_var_arr(\r\n+          running_var->template MutableData<T>(), C);\r\n+      running_mean_arr = running_mean_arr * momentum_ + saved_mean_arr * (1. - momentum_);\r\n+      running_var_arr = running_var_arr * momentum_ + saved_var_arr * (1. - momentum_);\r\n+    }\r\n+\r\n     // Regardless of training or testing, we will apply the estimated mean\r\n     // and standard deviation to the input. For testing, they are\r\n     // specified directly by the input, and for training, they are computed\r\n     // by the op.\r\n     Eigen::Array<T, Eigen::Dynamic, 1> inv_std(is_spatial_ ? C : sample_size_incl_all_channels);\r\n-    ConstEigenVectorArrayMap<T> var_arr(var->template Data<T>(), is_spatial_ ? C : sample_size_incl_all_channels);\r\n-    inv_std = (var_arr + epsilon_).sqrt().inverse();\r\n-    ConstEigenVectorArrayMap<T> mean_arr(mean->template Data<T>(), is_spatial_ ? C : sample_size_incl_all_channels);\r\n+\r\n+    if (!is_train_) {\r\n+      ConstEigenVectorArrayMap<T> var_arr(var->template Data<T>(), is_spatial_ ? C : sample_size_incl_all_channels);\r\n+      inv_std = (var_arr + epsilon_).sqrt().inverse();\r\n+    } else {\r\n+      // Note that, to be consistent with cudnn, we will actually output saved inverse std\r\n+      EigenVectorArrayMap<T> saved_inv_std(saved_var->template MutableData<T>(), C);\r\n+      saved_inv_std = (saved_inv_std + epsilon_).inverse().sqrt();\r\n+      inv_std = saved_inv_std;\r\n+    }\r\n+\r\n+    // If we're training, do batch normalization based on computation from this batch\r\n+    ConstEigenVectorArrayMap<T> mean_arr(\r\n+        !is_train_ ? mean->template Data<T>() : saved_mean->template Data<T>(), is_spatial_ ? C : sample_size_incl_all_channels);\r\n+\r\n     // We can fuse the output computation as follows:\r\n     //   ((x - est_mean) * (inv_var) * scale + bias\r\n     // to\r\n@@ -105,7 +157,8 @@ class BatchNorm : public OpKernel {\r\n \r\n  protected:\r\n   float epsilon_;\r\n+  float momentum_;\r\n   const bool is_spatial_;\r\n-  //int64_t is_test_;   ignored in this implementation since we're doing inferencing only.\r\n+  int64_t is_train_;\r\n };\r\n }  // namespace onnxruntime\r\ndiff --git a/orttraining/orttraining/core/framework/gradient_graph_builder.h b/orttraining/orttraining/core/framework/gradient_graph_builder.h\r\nindex 0aaf8a986..db6d203a4 100644\r\n--- a/orttraining/orttraining/core/framework/gradient_graph_builder.h\r\n+++ b/orttraining/orttraining/core/framework/gradient_graph_builder.h\r\n@@ -29,6 +29,7 @@ static std::unordered_map<std::string, std::unordered_set<size_t>>\r\n     STOP_GRADIENT_EDGES = {\r\n         {\"Not\", {0}},\r\n         {\"And\", {0, 1}},\r\n+        {\"BatchNormalization\", {3, 4}},\r\n         {\"Or\", {0, 1}},\r\n         {\"Xor\", {0, 1}},\r\n         {\"Equal\", {0, 1}},\r\ndiff --git a/orttraining/orttraining/training_ops/systolic/systolic_training_kernels.cc b/orttraining/orttraining/training_ops/systolic/systolic_training_kernels.cc\r\nindex 342a64ae4..6c2ab8d49 100644\r\n--- a/orttraining/orttraining/training_ops/systolic/systolic_training_kernels.cc\r\n+++ b/orttraining/orttraining/training_ops/systolic/systolic_training_kernels.cc\r\n@@ -13,6 +13,7 @@ namespace systolic {\r\n class ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kOnnxDomain, 9, ConvGrad);\r\n class ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kOnnxDomain, 9, ConvGrad_nhwc);\r\n class ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kOnnxDomain, 9, MaxPoolGrad_nhwc);\r\n+class ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kMSDomain, 1, BatchNormalizationGrad);\r\n #endif\r\n \r\n Status RegisterSystolicTrainingKernels(KernelRegistry& kernel_registry) {\r\n@@ -21,6 +22,7 @@ Status RegisterSystolicTrainingKernels(KernelRegistry& kernel_registry) {\r\n     BuildKernelCreateInfo<ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kOnnxDomain, 9, ConvGrad)>,\r\n     BuildKernelCreateInfo<ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kOnnxDomain, 9, ConvGrad_nhwc)>,\r\n     BuildKernelCreateInfo<ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kOnnxDomain, 9, MaxPoolGrad_nhwc)>,\r\n+    BuildKernelCreateInfo<ONNX_OPERATOR_KERNEL_CLASS_NAME(kSystolicExecutionProvider, kMSDomain, 1, BatchNormalizationGrad)>,\r\n #endif\r\n   };\r\n```\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/792230591/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/793194366",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6087#issuecomment-793194366",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6087",
        "id": 793194366,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc5MzE5NDM2Ng==",
        "user": {
            "login": "pranav-prakash",
            "id": 10335022,
            "node_id": "MDQ6VXNlcjEwMzM1MDIy",
            "avatar_url": "https://avatars.githubusercontent.com/u/10335022?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/pranav-prakash",
            "html_url": "https://github.com/pranav-prakash",
            "followers_url": "https://api.github.com/users/pranav-prakash/followers",
            "following_url": "https://api.github.com/users/pranav-prakash/following{/other_user}",
            "gists_url": "https://api.github.com/users/pranav-prakash/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/pranav-prakash/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/pranav-prakash/subscriptions",
            "organizations_url": "https://api.github.com/users/pranav-prakash/orgs",
            "repos_url": "https://api.github.com/users/pranav-prakash/repos",
            "events_url": "https://api.github.com/users/pranav-prakash/events{/privacy}",
            "received_events_url": "https://api.github.com/users/pranav-prakash/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-03-09T00:18:31Z",
        "updated_at": "2021-03-09T21:36:40Z",
        "author_association": "CONTRIBUTOR",
        "body": "I cleaned up the patch and opened a PR. @SherlockNoMad could you please review it?",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/793194366/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/943613095",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/6087#issuecomment-943613095",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/6087",
        "id": 943613095,
        "node_id": "IC_kwDOCVq1mM44PmSn",
        "user": {
            "login": "ashbhandare",
            "id": 14295305,
            "node_id": "MDQ6VXNlcjE0Mjk1MzA1",
            "avatar_url": "https://avatars.githubusercontent.com/u/14295305?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ashbhandare",
            "html_url": "https://github.com/ashbhandare",
            "followers_url": "https://api.github.com/users/ashbhandare/followers",
            "following_url": "https://api.github.com/users/ashbhandare/following{/other_user}",
            "gists_url": "https://api.github.com/users/ashbhandare/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/ashbhandare/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ashbhandare/subscriptions",
            "organizations_url": "https://api.github.com/users/ashbhandare/orgs",
            "repos_url": "https://api.github.com/users/ashbhandare/repos",
            "events_url": "https://api.github.com/users/ashbhandare/events{/privacy}",
            "received_events_url": "https://api.github.com/users/ashbhandare/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-10-14T18:29:13Z",
        "updated_at": "2021-10-14T18:29:13Z",
        "author_association": "CONTRIBUTOR",
        "body": "This issue should be resolved with PR #6946. Closing it, please feel free to reopen.",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/943613095/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]