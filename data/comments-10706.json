[
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057469609",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1057469609",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1057469609,
        "node_id": "IC_kwDOCVq1mM4_B7Sp",
        "user": {
            "login": "fdwr",
            "id": 1809166,
            "node_id": "MDQ6VXNlcjE4MDkxNjY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1809166?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fdwr",
            "html_url": "https://github.com/fdwr",
            "followers_url": "https://api.github.com/users/fdwr/followers",
            "following_url": "https://api.github.com/users/fdwr/following{/other_user}",
            "gists_url": "https://api.github.com/users/fdwr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fdwr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fdwr/subscriptions",
            "organizations_url": "https://api.github.com/users/fdwr/orgs",
            "repos_url": "https://api.github.com/users/fdwr/repos",
            "events_url": "https://api.github.com/users/fdwr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fdwr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-03-02T22:46:07Z",
        "updated_at": "2022-03-02T22:46:07Z",
        "author_association": "MEMBER",
        "body": "This sounds like https://github.com/microsoft/onnxruntime/issues/9409, but you tried PR 9929 already ðŸ¤”. What model are you executing? Private or publicly available?",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057469609/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057617595",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1057617595",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1057617595,
        "node_id": "IC_kwDOCVq1mM4_Cfa7",
        "user": {
            "login": "soloist-v",
            "id": 61590877,
            "node_id": "MDQ6VXNlcjYxNTkwODc3",
            "avatar_url": "https://avatars.githubusercontent.com/u/61590877?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/soloist-v",
            "html_url": "https://github.com/soloist-v",
            "followers_url": "https://api.github.com/users/soloist-v/followers",
            "following_url": "https://api.github.com/users/soloist-v/following{/other_user}",
            "gists_url": "https://api.github.com/users/soloist-v/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/soloist-v/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/soloist-v/subscriptions",
            "organizations_url": "https://api.github.com/users/soloist-v/orgs",
            "repos_url": "https://api.github.com/users/soloist-v/repos",
            "events_url": "https://api.github.com/users/soloist-v/events{/privacy}",
            "received_events_url": "https://api.github.com/users/soloist-v/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-03-03T03:00:43Z",
        "updated_at": "2022-03-03T03:00:43Z",
        "author_association": "NONE",
        "body": "This is my model  https://drive.google.com/file/d/12W5TOJIJzp9bCN9-CUaWbkLI0nynni0D/view?usp=sharing",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057617595/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057635393",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1057635393",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1057635393,
        "node_id": "IC_kwDOCVq1mM4_CjxB",
        "user": {
            "login": "fdwr",
            "id": 1809166,
            "node_id": "MDQ6VXNlcjE4MDkxNjY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1809166?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fdwr",
            "html_url": "https://github.com/fdwr",
            "followers_url": "https://api.github.com/users/fdwr/followers",
            "following_url": "https://api.github.com/users/fdwr/following{/other_user}",
            "gists_url": "https://api.github.com/users/fdwr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fdwr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fdwr/subscriptions",
            "organizations_url": "https://api.github.com/users/fdwr/orgs",
            "repos_url": "https://api.github.com/users/fdwr/repos",
            "events_url": "https://api.github.com/users/fdwr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fdwr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-03-03T03:43:08Z",
        "updated_at": "2022-03-03T03:43:37Z",
        "author_association": "MEMBER",
        "body": "Hmm, I'm not reproducing this with recent bits via [WinMLRunner](https://github.com/Microsoft/Windows-Machine-Learning/tree/master/Tools/WinMLRunner) (where WinML calls ONNX Runtime internally):\r\n\r\n```\r\nWinMLRunner_v1.2.1.2_x64.exe -gpuboundinput -gpu -model onnxruntime_github_issue_10706_yolox.onnx\r\n\r\nCreated LearningModelDevice with GPU: NVIDIA Quadro P400\r\nLoading model (path = onnxruntime_github_issue_10706_yolox.onnx)...\r\n=================================================================\r\nName: torch-jit-export\r\nAuthor: pytorch\r\nVersion: 0\r\nDomain:\r\nDescription:\r\nPath: D:\\tasks\\bugs\\onnxruntime_github_10706\\onnxruntime_github_issue_10706_yolox.onnx\r\nSupport FP16: false\r\n\r\nInput Feature Info:\r\nName: images\r\nFeature Kind: Float\r\n\r\nOutput Feature Info:\r\nName: output\r\nFeature Kind: Float\r\n\r\n=================================================================\r\n\r\nBinding (device = GPU, iteration = 1, inputBinding = GPU, inputDataType = Tensor, deviceCreationLocation = WinML)...[SUCCESS]\r\nEvaluating (device = GPU, iteration = 1, inputBinding = GPU, inputDataType = Tensor, deviceCreationLocation = WinML)...[SUCCESS]\r\n```\r\n\r\nIt sounds like you have already built it locally before (given you applied 9929). Does it repro for you with master? How are you calling it? (via C++/Python/CPU inputs/GPU inputs...?) I'm currently synchronized to https://github.com/microsoft/onnxruntime/commit/ea7f773a6e1244bab32ba791a3c855e4323d3135.",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057635393/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057648607",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1057648607",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1057648607,
        "node_id": "IC_kwDOCVq1mM4_Cm_f",
        "user": {
            "login": "soloist-v",
            "id": 61590877,
            "node_id": "MDQ6VXNlcjYxNTkwODc3",
            "avatar_url": "https://avatars.githubusercontent.com/u/61590877?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/soloist-v",
            "html_url": "https://github.com/soloist-v",
            "followers_url": "https://api.github.com/users/soloist-v/followers",
            "following_url": "https://api.github.com/users/soloist-v/following{/other_user}",
            "gists_url": "https://api.github.com/users/soloist-v/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/soloist-v/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/soloist-v/subscriptions",
            "organizations_url": "https://api.github.com/users/soloist-v/orgs",
            "repos_url": "https://api.github.com/users/soloist-v/repos",
            "events_url": "https://api.github.com/users/soloist-v/events{/privacy}",
            "received_events_url": "https://api.github.com/users/soloist-v/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-03-03T04:15:41Z",
        "updated_at": "2022-03-04T09:13:35Z",
        "author_association": "NONE",
        "body": "This is my code:\r\n```c++\r\n#include<string>\r\n#include <iostream>\r\n\r\ntemplate<typename T>\r\nstatic void __print(T &&t) {\r\n    std::cout << std::forward<T>(t) << \" \";\r\n}\r\n\r\ntemplate<typename T>\r\nstatic void __print__(std::ostream &out, T &&t) {\r\n    out << std::forward<T>(t) << \" \";\r\n}\r\n\r\ntemplate<typename ...Args>\r\nvoid print(Args... others) {\r\n    char a[] = {(__print(others), char(0))...};\r\n    std::cout << std::endl;\r\n}\r\n\r\ntemplate<class ...Args>\r\nvoid print(std::ostream &out, Args... others) {\r\n    char a[] = {(__print__(out, others), char(0))...};\r\n    out << std::endl;\r\n}\r\n\r\n#include <assert.h>\r\n#include <stdio.h>\r\n#include <onnxruntime_cxx_api.h>\r\n#include <dml_provider_factory.h>\r\n#include <objbase.h>\r\n#include <opencv2/opencv.hpp>\r\n#include<combaseapi.h>\r\n\r\nvoid hwc2chw_bgr2rgb(const uint8_t* input, size_t h, size_t w, float*& output_data) {\r\n    size_t stride = h * w;\r\n    //    auto *output_data = (float *) malloc(output_count * sizeof(float));\r\n    for (size_t i = 0; i != stride; ++i) {\r\n        //for (size_t c = 0; c != 3; ++c) {\r\n        //    output_data[c * stride + i] = (float)input[i * 3 + c];\r\n        //}\r\n        output_data[2 * stride + i] = (float)input[i * 3 + 0];\r\n        output_data[1 * stride + i] = (float)input[i * 3 + 1];\r\n        output_data[0 * stride + i] = (float)input[i * 3 + 2];\r\n    }\r\n}\r\n\r\nvoid hwc2chw_div_bgr2rgb(const uint8_t* input, size_t h, size_t w, float*& output_data, float std_val = 255.f) {\r\n    size_t stride = h * w;\r\n    //    auto *output_data = (float *) malloc(output_count * sizeof(float));\r\n    for (size_t i = 0; i != stride; ++i) {\r\n        //for (size_t c = 0; c != 3; ++c) {\r\n        //    output_data[c * stride + i] = (float)input[i * 3 + c] / std_val;\r\n        //}\r\n        output_data[2 * stride + i] = (float)input[i * 3 + 0] / std_val;\r\n        output_data[1 * stride + i] = (float)input[i * 3 + 1] / std_val;\r\n        output_data[0 * stride + i] = (float)input[i * 3 + 2] / std_val;\r\n    }\r\n}\r\n\r\nstatic char* convert_string(const wchar_t* input) {\r\n    size_t src_len = wcslen(input) + 1;\r\n    if (src_len > INT_MAX) {\r\n        printf(\"size overflow\\n\");\r\n        abort();\r\n    }\r\n    const int len = WideCharToMultiByte(CP_ACP, 0, input, (int)src_len, nullptr, 0, nullptr, nullptr);\r\n    assert(len > 0);\r\n    char* ret = (char*)malloc(len);\r\n    assert(ret != nullptr);\r\n    const int r = WideCharToMultiByte(CP_ACP, 0, input, (int)src_len, ret, len, nullptr, nullptr);\r\n    assert(len == r);\r\n    return ret;\r\n}\r\n\r\n//void enable_cuda(Ort::SessionOptions& session_options) {\r\n//    OrtCUDAProviderOptions options;\r\n//    /*options.device_id = 0;\r\n//    options.arena_extend_strategy = -1;\r\n//    options.gpu_mem_limit = 512 * 1024 * 1024;\r\n//    options.cudnn_conv_algo_search = OrtCudnnConvAlgoSearch::OrtCudnnConvAlgoSearchDefault;\r\n//    options.do_copy_in_default_stream = 1;*/\r\n//    options.device_id = 1;\r\n//    options.arena_extend_strategy = 1; // use -1 to allow ORT to choose the default, 0 = kNextPowerOfTwo, 1 = kSameAsRequested\r\n//    options.gpu_mem_limit = 1L * 1024 * 1024 * 1024;\r\n//    options.cudnn_conv_algo_search = OrtCudnnConvAlgoSearch::OrtCudnnConvAlgoSearchDefault;\r\n//    options.do_copy_in_default_stream = 1;\r\n//    options.user_compute_stream = nullptr;\r\n//    options.default_memory_arena_cfg = nullptr;\r\n//    session_options.AppendExecutionProvider_CUDA(options);\r\n//    //Ort::GetApi().SessionOptionsAppendExecutionProvider_CUDA(*session_options, &options);\r\n//}\r\n\r\nconst OrtApi* g_api = nullptr;\r\n\r\nint enable_cuda(OrtSessionOptions* session_options) {\r\n    //OrtSessionOptions* session_options = /* ... */;\r\n    OrtCUDAProviderOptions options;\r\n    options.device_id = 0;\r\n    options.arena_extend_strategy = 0;\r\n    options.gpu_mem_limit = 512 * 1024 * 1024;\r\n    options.cudnn_conv_algo_search = OrtCudnnConvAlgoSearch::OrtCudnnConvAlgoSearchExhaustive;\r\n    options.do_copy_in_default_stream = 1;\r\n    g_api->SessionOptionsAppendExecutionProvider_CUDA(session_options, &options);\r\n    return 0;\r\n}\r\n\r\nvoid enable_dml(OrtSessionOptions* session_options) {\r\n    //    ORT_ABORT_ON_ERROR(OrtSessionOptionsAppendExecutionProvider_DML(session_options, 0));\r\n    OrtSessionOptionsAppendExecutionProvider_DML(session_options, 0);\r\n}\r\n\r\nstruct BBox {\r\n    float xmin;\r\n    float ymin;\r\n    float xmax;\r\n    float ymax;\r\n};\r\n\r\nstruct Result {\r\n    BBox box;\r\n    int cls;\r\n    float score;\r\n\r\n    Result() = default;\r\n\r\n    ~Result() = default;\r\n\r\n    bool operator<(const Result& t) const { return score < t.score; }\r\n\r\n    bool operator>(const Result& t) const { return score > t.score; }\r\n\r\n    friend std::ostream& operator <<(std::ostream &out, Result& res) {\r\n        print(out, res.box.xmin,res.box.ymin, res.box.xmax, res.box.ymax, res.cls, res.score);\r\n        return out;\r\n    }\r\n};\r\n\r\nfloat inline sigmoid(float input) {\r\n    return input;\r\n    //    return 1.0 / (1.0 + exp(-input));\r\n}\r\n\r\ntemplate<class T>\r\nT prod(std::vector<T>& vector) {\r\n    T res = 1;\r\n    for (auto v : vector) {\r\n        res *= v;\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid nms_cpu(std::vector<Result>& boxes, float threshold, std::vector<Result>& filterOutBoxes) {\r\n\r\n    if (boxes.empty())\r\n        return;\r\n    std::vector<size_t> idx(boxes.size());\r\n\r\n    for (unsigned i = 0; i < idx.size(); i++) {\r\n        idx[i] = i;\r\n    }\r\n\r\n    sort(boxes.begin(), boxes.end(), std::greater<Result>());\r\n\r\n    while (!idx.empty()) {\r\n        auto good_idx = idx[0];\r\n        filterOutBoxes.push_back(boxes[good_idx]);\r\n\r\n        std::vector<size_t> tmp = idx;\r\n        idx.clear();\r\n        for (unsigned i = 1; i < tmp.size(); i++) {\r\n            auto tmp_i = tmp[i];\r\n            float inter_x1 = std::max(boxes[good_idx].box.xmin, boxes[tmp_i].box.xmin);\r\n            float inter_y1 = std::max(boxes[good_idx].box.ymin, boxes[tmp_i].box.ymin);\r\n            float inter_x2 = std::min(boxes[good_idx].box.xmax, boxes[tmp_i].box.xmax);\r\n            float inter_y2 = std::min(boxes[good_idx].box.ymax, boxes[tmp_i].box.ymax);\r\n\r\n            float w = std::max((inter_x2 - inter_x1 + 1), 0.0F);\r\n            float h = std::max((inter_y2 - inter_y1 + 1), 0.0F);\r\n\r\n            float inter_area = w * h;\r\n            float area_1 = (boxes[good_idx].box.xmax - boxes[good_idx].box.xmin + 1) *\r\n                (boxes[good_idx].box.ymax - boxes[good_idx].box.ymin + 1);\r\n            float area_2 = (boxes[tmp_i].box.xmax - boxes[tmp_i].box.xmin + 1) *\r\n                (boxes[tmp_i].box.ymax - boxes[tmp_i].box.ymin + 1);\r\n            float o = inter_area / (area_1 + area_2 - inter_area);\r\n            if (o <= threshold)\r\n                idx.push_back(tmp_i);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass YoloBase {\r\npublic:\r\n    YoloBase(const wchar_t* model_path, int device_id);\r\n\r\n    ~YoloBase() {\r\n        allocator.Free(input_data);\r\n        allocator.Free(output_data);\r\n        session_options.release();\r\n        session.release();\r\n        env.release();\r\n        allocator.Free(input_name);\r\n        allocator.Free(output_name);\r\n        CoUninitialize();\r\n    }\r\n\r\nprivate:\r\n    const wchar_t* model_path;\r\n    int device_id = 0;\r\n    Ort::Env env;\r\n    Ort::RunOptions options;\r\n    Ort::MemoryInfo memoryInfo;\r\n    Ort::SessionOptions session_options;\r\n    Ort::AllocatorWithDefaultOptions allocator;\r\n    Ort::Session session = Ort::Session(nullptr);\r\n    char* input_name;\r\n    char* output_name;\r\n    std::vector<int64_t> shape_in;\r\n    std::vector<int64_t> shape_out;\r\n    size_t batch_size;\r\n    size_t channel;\r\n    size_t width;\r\n    size_t height;\r\n    float conf_thres = 0.3;\r\n    float iou_thres = 0.0001;\r\n    float* input_data;\r\n    size_t input_size;\r\n    float* output_data;\r\n    size_t output_size;\r\n    const char* input_names[1] = { \"images\" };\r\n    const char* output_names[1] = { \"output\" };\r\n    const wchar_t* opt_model_path = L\"./temp_opt_model.data\";\r\n\r\n    friend class YoloXDetector;\r\n\r\n    friend class YoloV5Detector;\r\n\r\npublic:\r\n    friend std::ostream& operator<<(std::ostream& out, YoloBase* detector) {\r\n        print(out, typeid(detector).name(), \"{\");\r\n        print(out, detector->device_id);\r\n        print(out, detector->model_path);\r\n        print(out, \"}\");\r\n        return out;\r\n    }\r\n\r\n    virtual void detect(cv::Mat& _img, std::vector<Result>& res) = 0;\r\n\r\n    int post_process(Ort::Value& _pred, float ratio, std::vector<Result>& res) const;\r\n\r\n    float preprocess(cv::Mat& img, cv::Mat& dst) const;\r\n};\r\n\r\nYoloBase::YoloBase(const wchar_t* model_path, int device_id) :\r\n    env(ORT_LOGGING_LEVEL_WARNING, \"YoloBase\"),\r\n    memoryInfo(nullptr) {\r\n    this->model_path = model_path;\r\n    this->device_id = device_id;\r\n    // CoInitializeEx is only needed if Windows Image Component will be used in this program for image loading/saving.\r\n    HRESULT hr = CoInitializeEx(nullptr, COINIT_MULTITHREADED);\r\n    if (!SUCCEEDED(hr)) return;\r\n    session_options.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_ALL);\r\n    session_options.DisableMemPattern();\r\n    session_options.SetExecutionMode(ExecutionMode::ORT_SEQUENTIAL);\r\n    OrtSessionOptionsAppendExecutionProvider_DML(session_options, device_id);\r\n    session_options.SetOptimizedModelFilePath(opt_model_path);\r\n    this->session = Ort::Session(env, model_path, session_options);\r\n    input_name = session.GetInputName(0, allocator);\r\n    output_name = session.GetOutputName(0, allocator);\r\n    auto input_info = session.GetInputTypeInfo(0);\r\n    auto output_info = session.GetOutputTypeInfo(0);\r\n    shape_in = input_info.GetTensorTypeAndShapeInfo().GetShape();  // B C H W\r\n    shape_out = output_info.GetTensorTypeAndShapeInfo().GetShape();\r\n    batch_size = 1;\r\n    channel = shape_in[1];\r\n    height = shape_in[2];\r\n    width = shape_in[3];\r\n    shape_in[0] = batch_size;\r\n    shape_out[0] = batch_size;\r\n    input_size = prod(shape_in);\r\n    output_size = prod(shape_out);\r\n    input_data = (float*)allocator.Alloc(input_size * sizeof(float));\r\n    output_data = (float*)allocator.Alloc(output_size * sizeof(float));\r\n    memoryInfo = Ort::MemoryInfo::CreateCpu(OrtAllocatorType::OrtArenaAllocator, OrtMemType::OrtMemTypeDefault);\r\n}\r\n\r\nfloat YoloBase::preprocess(cv::Mat& img, cv::Mat& dst) const {\r\n    auto h = img.rows;\r\n    auto w = img.cols;\r\n    auto ratio = std::min<float>((float)width / (float)w, (float)height / (float)h);\r\n    ratio = std::min(ratio, 1.f);\r\n    auto new_w = int((float)w * ratio);\r\n    auto new_h = int((float)h * ratio);\r\n    cv::resize(img, dst, cv::Size(new_w, new_h), 0, 0, cv::INTER_NEAREST);\r\n    cv::Mat temp;\r\n    cv::copyMakeBorder(dst, temp, 0, height - new_h, 0, width - new_w,\r\n        cv::BORDER_CONSTANT, cv::Scalar(114));\r\n    dst = temp;\r\n    //cv::cvtColor(temp, dst, cv::COLOR_BGR2RGB);\r\n    return ratio;\r\n}\r\n\r\nint YoloBase::post_process(Ort::Value& _pred, float ratio, std::vector<Result>& res) const {\r\n    std::map<int, std::vector<Result>> map_anchors;\r\n    auto shape = _pred.GetTensorTypeAndShapeInfo().GetShape();\r\n    auto pred = _pred.GetTensorMutableData<float>();\r\n    auto grids = shape[1];\r\n    auto xywhn = shape[2];\r\n    auto nc = xywhn - 5;\r\n    for (size_t bs = 0; bs < batch_size; bs++) {\r\n        for (size_t i_grid = 0; i_grid < grids; ++i_grid) {\r\n            auto pos = bs * grids * xywhn + i_grid * xywhn;\r\n            float obj_conf = sigmoid(pred[4 + pos]);\r\n            if (obj_conf < conf_thres) continue;\r\n            float c_x = sigmoid(pred[0 + pos]);\r\n            float c_y = sigmoid(pred[1 + pos]);\r\n            float c_w = sigmoid(pred[2 + pos]);\r\n            float c_h = sigmoid(pred[3 + pos]);\r\n\r\n            float max_pred_conf = 0.;\r\n            int max_pred_conf_idx = 0;\r\n\r\n            for (int i = 0; i < nc; i++) {\r\n                float cls_conf = sigmoid(pred[pos + 5 + i]);\r\n                float tmp_score = obj_conf * cls_conf;\r\n                if (max_pred_conf < tmp_score) {\r\n                    max_pred_conf_idx = i;\r\n                    max_pred_conf = tmp_score;\r\n                }\r\n            }\r\n            if (max_pred_conf < conf_thres) continue;\r\n            Result anchor{};\r\n            anchor.score = max_pred_conf;\r\n            anchor.cls = max_pred_conf_idx;\r\n            anchor.box.xmin = (c_x - 0.5f * c_w) / ratio;\r\n            anchor.box.ymin = (c_y - 0.5f * c_h) / ratio;\r\n            anchor.box.xmax = (c_x + 0.5f * c_w) / ratio;\r\n            anchor.box.ymax = (c_y + 0.5f * c_h) / ratio;\r\n            if (map_anchors.find(max_pred_conf_idx) == map_anchors.end()) {\r\n                std::vector<Result> tmp_anchor{ anchor };\r\n                map_anchors[max_pred_conf_idx] = tmp_anchor;\r\n            }\r\n            else {\r\n                map_anchors[max_pred_conf_idx].push_back(anchor);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < nc; i++) {\r\n        if (map_anchors.find(i) != map_anchors.end()) {\r\n            nms_cpu(map_anchors[i], iou_thres, res);\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nclass YoloV5Detector : public virtual YoloBase {\r\npublic:\r\n    YoloV5Detector(const wchar_t* model_path, int device_id) :\r\n        YoloBase{ model_path, device_id } {};\r\n\r\n    void detect(cv::Mat& _img, std::vector<Result>& res) override {\r\n        cv::Mat img;\r\n        float ratio = preprocess(_img, img);\r\n        hwc2chw_div_bgr2rgb(img.data, img.rows, img.cols, input_data);\r\n        Ort::Value input_value = Ort::Value::CreateTensor<float>(memoryInfo, (float*)input_data,\r\n            input_size, shape_in.data(), shape_in.size());\r\n        Ort::Value output_value = Ort::Value::CreateTensor<float>(memoryInfo, (float*)output_data,\r\n            output_size, shape_out.data(), shape_out.size());\r\n        session.Run(options, input_names, &input_value, 1, output_names, &output_value, 1);\r\n        post_process(output_value, ratio, res);\r\n        output_value.release();\r\n        input_value.release();\r\n    }\r\n};\r\n\r\nclass YoloXDetector : public virtual YoloBase {\r\npublic:\r\n    YoloXDetector(const wchar_t* model_path, int device_id) :\r\n        YoloBase{ model_path, device_id } {};\r\n\r\n    void detect(cv::Mat& _img, std::vector<Result>& res) override {\r\n        cv::Mat img;\r\n        float ratio = preprocess(_img, img);\r\n        hwc2chw_bgr2rgb(img.data, img.rows, img.cols, input_data);\r\n        Ort::Value input_value = Ort::Value::CreateTensor<float>(memoryInfo, (float*)input_data,\r\n            input_size, shape_in.data(), shape_in.size());\r\n        Ort::Value output_value = Ort::Value::CreateTensor<float>(memoryInfo, (float*)output_data,\r\n            output_size, shape_out.data(), shape_out.size());\r\n        session.Run(options, input_names, &input_value, 1, output_names, &output_value, 1);\r\n        post_process(output_value, ratio, res);\r\n        output_value.release();\r\n        input_value.release();\r\n    }\r\n};\r\n\r\n#pragma warning(disable : 4996)\r\n\r\nstd::string WString2String(const std::wstring& ws) {\r\n    std::string strLocale = std::setlocale(LC_ALL, \"\");\r\n    const wchar_t* wchSrc = ws.c_str();\r\n    size_t nDestSize = wcstombs(nullptr, wchSrc, 0) + 1;\r\n    char* chDest = new char[nDestSize];\r\n    memset(chDest, 0, nDestSize);\r\n    std::wcstombs(chDest, wchSrc, nDestSize);\r\n    std::string strResult = chDest;\r\n    delete[]chDest;\r\n    std::setlocale(LC_ALL, strLocale.c_str());\r\n    return strResult;\r\n}\r\n\r\n#include <d3d11_1.h>\r\n#include <d3dcompiler.h>\r\n\r\nint auto_device_id() {\r\n    IDXGIAdapter* pAdapter;\r\n    IDXGIFactory* pFactory = nullptr;\r\n    CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory);\r\n    int max_mem = 0;\r\n    UINT max_did = 0;\r\n    for (UINT i = 0; pFactory->EnumAdapters(i, &pAdapter) != DXGI_ERROR_NOT_FOUND; ++i) {\r\n        DXGI_ADAPTER_DESC desc{};\r\n        pAdapter->GetDesc(&desc);\r\n        print(\"device\", i, WString2String(std::wstring(desc.Description)), desc.DeviceId);\r\n        print(\"DedicatedVideoMemory\", desc.DedicatedVideoMemory);\r\n        print(\"AdapterLuid\", desc.AdapterLuid.HighPart, desc.AdapterLuid.LowPart);\r\n        print(\"Revision\", desc.Revision);\r\n        print(\"SharedSystemMemory\", desc.SharedSystemMemory);\r\n        print(\"DedicatedSystemMemory\", desc.DedicatedSystemMemory);\r\n        if (desc.DedicatedVideoMemory > max_mem) {\r\n            max_mem = desc.DedicatedVideoMemory;\r\n            max_did = i;\r\n        }\r\n    }\r\n    print(\"auto select device:\", max_did);\r\n    return max_did;\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    int device_id;\r\n    device_id = auto_device_id();\r\n    //device_id = 3;\r\n    //return 0;\r\n    // ------------------------------------------\r\n    g_api = OrtGetApiBase()->GetApi(ORT_API_VERSION);\r\n    print(\"----start-------\");\r\n    YoloXDetector detector{ L\"yolox.onnx\", device_id };\r\n    //YoloV5Detector detector{ L\"model.onnx\", device_id };\r\n    print(\"load model success\");\r\n    std::vector<Result> res;\r\n    res.reserve(10);\r\n    auto img = cv::imread(\"test.png\");\r\n    assert(!img.empty());\r\n    for (size_t i = 0; i < 20; i++) {\r\n        res.clear();\r\n        auto t0 = std::chrono::high_resolution_clock::now();\r\n        detector.detect(img, res);\r\n        auto dt = std::chrono::high_resolution_clock::now() - t0;\r\n        print(\"time:\", dt.count() / 1000000.f);\r\n        //print(\"size:\", res.size());\r\n    }\r\n    for (auto i : res) {\r\n        print(i);\r\n        auto cls = std::to_string(i.cls);\r\n        auto box = i.box;\r\n        int x = i.box.xmin;\r\n        int y = i.box.ymin;\r\n        int w = i.box.xmax - i.box.xmin;\r\n        int h = i.box.ymax - i.box.ymin;\r\n        cv::rectangle(img, cv::Rect{ x, y, w, h }, cv::Scalar{ 0, 255, 0 });\r\n    }\r\n    //cv::imshow(\"res\", img);\r\n    //cv::waitKey();\r\n    //cv::destroyWindow(\"res\");\r\n    return 0;\r\n}\r\n```\r\nWhen i use  `session.Run(options, input_names, &input_value, 1, output_names, &output_value, 1);` i get the error",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057648607/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057674000",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1057674000",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1057674000,
        "node_id": "IC_kwDOCVq1mM4_CtMQ",
        "user": {
            "login": "soloist-v",
            "id": 61590877,
            "node_id": "MDQ6VXNlcjYxNTkwODc3",
            "avatar_url": "https://avatars.githubusercontent.com/u/61590877?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/soloist-v",
            "html_url": "https://github.com/soloist-v",
            "followers_url": "https://api.github.com/users/soloist-v/followers",
            "following_url": "https://api.github.com/users/soloist-v/following{/other_user}",
            "gists_url": "https://api.github.com/users/soloist-v/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/soloist-v/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/soloist-v/subscriptions",
            "organizations_url": "https://api.github.com/users/soloist-v/orgs",
            "repos_url": "https://api.github.com/users/soloist-v/repos",
            "events_url": "https://api.github.com/users/soloist-v/events{/privacy}",
            "received_events_url": "https://api.github.com/users/soloist-v/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-03-03T05:14:20Z",
        "updated_at": "2022-03-03T05:14:20Z",
        "author_association": "NONE",
        "body": "I tried MicrosoftMLRunner.exe, it is ok[`MicrosoftMLRunner.exe -gpuboundinput -gpu -model ../../../yolox.onnx`], but when I copied `MicrosoftMLRunner.exe`'s `directml.dll` and `onnxruntime.dll` to my program directory, the problem still exists.\r\n### Console output\r\n```\r\nD:\\Downloads\\MicrosoftMLRunner\\MicrosoftMLRunner\\x64>MicrosoftMLRunner.exe -gpuboundinput -gpu -model ../../../yolox.onnx\r\n\r\nCreated LearningModelDevice with GPU: Intel(R) UHD Graphics\r\nLoading model (path = D:\\Downloads\\yolox.onnx)...\r\n=================================================================\r\nName: torch-jit-export\r\nAuthor: pytorch\r\nVersion: 0\r\nDomain:\r\nDescription:\r\nPath: D:\\Downloads\\yolox.onnx\r\nSupport FP16: false\r\n\r\nInput Feature Info:\r\nName: images\r\nFeature Kind: Float\r\n\r\nOutput Feature Info:\r\nName: output\r\nFeature Kind: Float\r\n\r\n=================================================================\r\n\r\nBinding (device = GPU, iteration = 1, inputBinding = GPU, inputDataType = Tensor, deviceCreationLocation = WinML)...[SUCCESS]\r\nEvaluating (device = GPU, iteration = 1, inputBinding = GPU, inputDataType = Tensor, deviceCreationLocation = WinML)...[SUCCESS]\r\n```\r\nWhen i use `session.Run(options, input_names, &input_value, 1, output_names, &output_value, 1);` i get the error\r\n### System Info\r\nos: Windows 11 21H2\r\nbuild tools: Visual Studio 2019 (v142)\r\nWindows SDK: 10.0.19041.0\r\nc++: ISO C++14 \r\n",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1057674000/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1159314853",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1159314853",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1159314853,
        "node_id": "IC_kwDOCVq1mM5FGb2l",
        "user": {
            "login": "sumitsays",
            "id": 11188170,
            "node_id": "MDQ6VXNlcjExMTg4MTcw",
            "avatar_url": "https://avatars.githubusercontent.com/u/11188170?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sumitsays",
            "html_url": "https://github.com/sumitsays",
            "followers_url": "https://api.github.com/users/sumitsays/followers",
            "following_url": "https://api.github.com/users/sumitsays/following{/other_user}",
            "gists_url": "https://api.github.com/users/sumitsays/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/sumitsays/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/sumitsays/subscriptions",
            "organizations_url": "https://api.github.com/users/sumitsays/orgs",
            "repos_url": "https://api.github.com/users/sumitsays/repos",
            "events_url": "https://api.github.com/users/sumitsays/events{/privacy}",
            "received_events_url": "https://api.github.com/users/sumitsays/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-06-18T00:16:20Z",
        "updated_at": "2022-06-18T00:25:24Z",
        "author_association": "MEMBER",
        "body": "The fix of this issue will be released as part of ORT next release. Please try when ORT1.12 will be released.",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1159314853/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1191826072",
        "html_url": "https://github.com/microsoft/onnxruntime/issues/10706#issuecomment-1191826072",
        "issue_url": "https://api.github.com/repos/microsoft/onnxruntime/issues/10706",
        "id": 1191826072,
        "node_id": "IC_kwDOCVq1mM5HCdKY",
        "user": {
            "login": "fdwr",
            "id": 1809166,
            "node_id": "MDQ6VXNlcjE4MDkxNjY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1809166?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fdwr",
            "html_url": "https://github.com/fdwr",
            "followers_url": "https://api.github.com/users/fdwr/followers",
            "following_url": "https://api.github.com/users/fdwr/following{/other_user}",
            "gists_url": "https://api.github.com/users/fdwr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fdwr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fdwr/subscriptions",
            "organizations_url": "https://api.github.com/users/fdwr/orgs",
            "repos_url": "https://api.github.com/users/fdwr/repos",
            "events_url": "https://api.github.com/users/fdwr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fdwr/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-07-21T18:53:53Z",
        "updated_at": "2022-07-21T18:53:53Z",
        "author_association": "MEMBER",
        "body": "@soloist-v ORT 1.12 should be out very soon. In the meantime, you can use `master` or the `rel-1.12.0` branch https://github.com/microsoft/onnxruntime/tree/rel-1.12.0",
        "reactions": {
            "url": "https://api.github.com/repos/microsoft/onnxruntime/issues/comments/1191826072/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]